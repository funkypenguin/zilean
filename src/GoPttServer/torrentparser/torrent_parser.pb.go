// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v5.29.3
// source: torrent_parser.proto

package torrentparser

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type TorrentTitleRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	InfoHash      string                 `protobuf:"bytes,1,opt,name=info_hash,json=infoHash,proto3" json:"info_hash,omitempty"`
	Title         string                 `protobuf:"bytes,2,opt,name=title,proto3" json:"title,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TorrentTitleRequest) Reset() {
	*x = TorrentTitleRequest{}
	mi := &file_torrent_parser_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TorrentTitleRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TorrentTitleRequest) ProtoMessage() {}

func (x *TorrentTitleRequest) ProtoReflect() protoreflect.Message {
	mi := &file_torrent_parser_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TorrentTitleRequest.ProtoReflect.Descriptor instead.
func (*TorrentTitleRequest) Descriptor() ([]byte, []int) {
	return file_torrent_parser_proto_rawDescGZIP(), []int{0}
}

func (x *TorrentTitleRequest) GetInfoHash() string {
	if x != nil {
		return x.InfoHash
	}
	return ""
}

func (x *TorrentTitleRequest) GetTitle() string {
	if x != nil {
		return x.Title
	}
	return ""
}

type TorrentTitleResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	InfoHash      string                 `protobuf:"bytes,1,opt,name=info_hash,json=infoHash,proto3" json:"info_hash,omitempty"`
	OriginalTitle string                 `protobuf:"bytes,2,opt,name=original_title,json=originalTitle,proto3" json:"original_title,omitempty"`
	Audio         []string               `protobuf:"bytes,3,rep,name=audio,proto3" json:"audio,omitempty"`
	BitDepth      string                 `protobuf:"bytes,4,opt,name=bit_depth,json=bitDepth,proto3" json:"bit_depth,omitempty"`
	Channels      []string               `protobuf:"bytes,5,rep,name=channels,proto3" json:"channels,omitempty"`
	Codec         string                 `protobuf:"bytes,6,opt,name=codec,proto3" json:"codec,omitempty"`
	Commentary    bool                   `protobuf:"varint,7,opt,name=commentary,proto3" json:"commentary,omitempty"`
	Complete      bool                   `protobuf:"varint,8,opt,name=complete,proto3" json:"complete,omitempty"`
	Container     string                 `protobuf:"bytes,9,opt,name=container,proto3" json:"container,omitempty"`
	Convert       bool                   `protobuf:"varint,10,opt,name=convert,proto3" json:"convert,omitempty"`
	Date          string                 `protobuf:"bytes,11,opt,name=date,proto3" json:"date,omitempty"`
	Documentary   bool                   `protobuf:"varint,12,opt,name=documentary,proto3" json:"documentary,omitempty"`
	Dubbed        bool                   `protobuf:"varint,13,opt,name=dubbed,proto3" json:"dubbed,omitempty"`
	Edition       string                 `protobuf:"bytes,14,opt,name=edition,proto3" json:"edition,omitempty"`
	EpisodeCode   string                 `protobuf:"bytes,15,opt,name=episode_code,json=episodeCode,proto3" json:"episode_code,omitempty"`
	Episodes      []int32                `protobuf:"varint,16,rep,packed,name=episodes,proto3" json:"episodes,omitempty"`
	Extended      bool                   `protobuf:"varint,17,opt,name=extended,proto3" json:"extended,omitempty"`
	Extension     string                 `protobuf:"bytes,18,opt,name=extension,proto3" json:"extension,omitempty"`
	Group         string                 `protobuf:"bytes,19,opt,name=group,proto3" json:"group,omitempty"`
	Hdr           []string               `protobuf:"bytes,20,rep,name=hdr,proto3" json:"hdr,omitempty"`
	Hardcoded     bool                   `protobuf:"varint,21,opt,name=hardcoded,proto3" json:"hardcoded,omitempty"`
	Languages     []string               `protobuf:"bytes,22,rep,name=languages,proto3" json:"languages,omitempty"`
	Network       string                 `protobuf:"bytes,23,opt,name=network,proto3" json:"network,omitempty"`
	Proper        bool                   `protobuf:"varint,24,opt,name=proper,proto3" json:"proper,omitempty"`
	Quality       string                 `protobuf:"bytes,25,opt,name=quality,proto3" json:"quality,omitempty"`
	Region        string                 `protobuf:"bytes,26,opt,name=region,proto3" json:"region,omitempty"`
	Remastered    bool                   `protobuf:"varint,27,opt,name=remastered,proto3" json:"remastered,omitempty"`
	Repack        bool                   `protobuf:"varint,28,opt,name=repack,proto3" json:"repack,omitempty"`
	Resolution    string                 `protobuf:"bytes,29,opt,name=resolution,proto3" json:"resolution,omitempty"`
	Retail        bool                   `protobuf:"varint,30,opt,name=retail,proto3" json:"retail,omitempty"`
	Seasons       []int32                `protobuf:"varint,31,rep,packed,name=seasons,proto3" json:"seasons,omitempty"`
	Site          string                 `protobuf:"bytes,32,opt,name=site,proto3" json:"site,omitempty"`
	Size          string                 `protobuf:"bytes,33,opt,name=size,proto3" json:"size,omitempty"`
	Subbed        bool                   `protobuf:"varint,34,opt,name=subbed,proto3" json:"subbed,omitempty"`
	ThreeD        string                 `protobuf:"bytes,35,opt,name=three_d,json=threeD,proto3" json:"three_d,omitempty"`
	Title         string                 `protobuf:"bytes,36,opt,name=title,proto3" json:"title,omitempty"`
	Uncensored    bool                   `protobuf:"varint,37,opt,name=uncensored,proto3" json:"uncensored,omitempty"`
	Unrated       bool                   `protobuf:"varint,38,opt,name=unrated,proto3" json:"unrated,omitempty"`
	Upscaled      bool                   `protobuf:"varint,39,opt,name=upscaled,proto3" json:"upscaled,omitempty"`
	Volumes       []int32                `protobuf:"varint,40,rep,packed,name=volumes,proto3" json:"volumes,omitempty"`
	Year          string                 `protobuf:"bytes,41,opt,name=year,proto3" json:"year,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TorrentTitleResponse) Reset() {
	*x = TorrentTitleResponse{}
	mi := &file_torrent_parser_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TorrentTitleResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TorrentTitleResponse) ProtoMessage() {}

func (x *TorrentTitleResponse) ProtoReflect() protoreflect.Message {
	mi := &file_torrent_parser_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TorrentTitleResponse.ProtoReflect.Descriptor instead.
func (*TorrentTitleResponse) Descriptor() ([]byte, []int) {
	return file_torrent_parser_proto_rawDescGZIP(), []int{1}
}

func (x *TorrentTitleResponse) GetInfoHash() string {
	if x != nil {
		return x.InfoHash
	}
	return ""
}

func (x *TorrentTitleResponse) GetOriginalTitle() string {
	if x != nil {
		return x.OriginalTitle
	}
	return ""
}

func (x *TorrentTitleResponse) GetAudio() []string {
	if x != nil {
		return x.Audio
	}
	return nil
}

func (x *TorrentTitleResponse) GetBitDepth() string {
	if x != nil {
		return x.BitDepth
	}
	return ""
}

func (x *TorrentTitleResponse) GetChannels() []string {
	if x != nil {
		return x.Channels
	}
	return nil
}

func (x *TorrentTitleResponse) GetCodec() string {
	if x != nil {
		return x.Codec
	}
	return ""
}

func (x *TorrentTitleResponse) GetCommentary() bool {
	if x != nil {
		return x.Commentary
	}
	return false
}

func (x *TorrentTitleResponse) GetComplete() bool {
	if x != nil {
		return x.Complete
	}
	return false
}

func (x *TorrentTitleResponse) GetContainer() string {
	if x != nil {
		return x.Container
	}
	return ""
}

func (x *TorrentTitleResponse) GetConvert() bool {
	if x != nil {
		return x.Convert
	}
	return false
}

func (x *TorrentTitleResponse) GetDate() string {
	if x != nil {
		return x.Date
	}
	return ""
}

func (x *TorrentTitleResponse) GetDocumentary() bool {
	if x != nil {
		return x.Documentary
	}
	return false
}

func (x *TorrentTitleResponse) GetDubbed() bool {
	if x != nil {
		return x.Dubbed
	}
	return false
}

func (x *TorrentTitleResponse) GetEdition() string {
	if x != nil {
		return x.Edition
	}
	return ""
}

func (x *TorrentTitleResponse) GetEpisodeCode() string {
	if x != nil {
		return x.EpisodeCode
	}
	return ""
}

func (x *TorrentTitleResponse) GetEpisodes() []int32 {
	if x != nil {
		return x.Episodes
	}
	return nil
}

func (x *TorrentTitleResponse) GetExtended() bool {
	if x != nil {
		return x.Extended
	}
	return false
}

func (x *TorrentTitleResponse) GetExtension() string {
	if x != nil {
		return x.Extension
	}
	return ""
}

func (x *TorrentTitleResponse) GetGroup() string {
	if x != nil {
		return x.Group
	}
	return ""
}

func (x *TorrentTitleResponse) GetHdr() []string {
	if x != nil {
		return x.Hdr
	}
	return nil
}

func (x *TorrentTitleResponse) GetHardcoded() bool {
	if x != nil {
		return x.Hardcoded
	}
	return false
}

func (x *TorrentTitleResponse) GetLanguages() []string {
	if x != nil {
		return x.Languages
	}
	return nil
}

func (x *TorrentTitleResponse) GetNetwork() string {
	if x != nil {
		return x.Network
	}
	return ""
}

func (x *TorrentTitleResponse) GetProper() bool {
	if x != nil {
		return x.Proper
	}
	return false
}

func (x *TorrentTitleResponse) GetQuality() string {
	if x != nil {
		return x.Quality
	}
	return ""
}

func (x *TorrentTitleResponse) GetRegion() string {
	if x != nil {
		return x.Region
	}
	return ""
}

func (x *TorrentTitleResponse) GetRemastered() bool {
	if x != nil {
		return x.Remastered
	}
	return false
}

func (x *TorrentTitleResponse) GetRepack() bool {
	if x != nil {
		return x.Repack
	}
	return false
}

func (x *TorrentTitleResponse) GetResolution() string {
	if x != nil {
		return x.Resolution
	}
	return ""
}

func (x *TorrentTitleResponse) GetRetail() bool {
	if x != nil {
		return x.Retail
	}
	return false
}

func (x *TorrentTitleResponse) GetSeasons() []int32 {
	if x != nil {
		return x.Seasons
	}
	return nil
}

func (x *TorrentTitleResponse) GetSite() string {
	if x != nil {
		return x.Site
	}
	return ""
}

func (x *TorrentTitleResponse) GetSize() string {
	if x != nil {
		return x.Size
	}
	return ""
}

func (x *TorrentTitleResponse) GetSubbed() bool {
	if x != nil {
		return x.Subbed
	}
	return false
}

func (x *TorrentTitleResponse) GetThreeD() string {
	if x != nil {
		return x.ThreeD
	}
	return ""
}

func (x *TorrentTitleResponse) GetTitle() string {
	if x != nil {
		return x.Title
	}
	return ""
}

func (x *TorrentTitleResponse) GetUncensored() bool {
	if x != nil {
		return x.Uncensored
	}
	return false
}

func (x *TorrentTitleResponse) GetUnrated() bool {
	if x != nil {
		return x.Unrated
	}
	return false
}

func (x *TorrentTitleResponse) GetUpscaled() bool {
	if x != nil {
		return x.Upscaled
	}
	return false
}

func (x *TorrentTitleResponse) GetVolumes() []int32 {
	if x != nil {
		return x.Volumes
	}
	return nil
}

func (x *TorrentTitleResponse) GetYear() string {
	if x != nil {
		return x.Year
	}
	return ""
}

type ShutdownRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ShutdownRequest) Reset() {
	*x = ShutdownRequest{}
	mi := &file_torrent_parser_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ShutdownRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ShutdownRequest) ProtoMessage() {}

func (x *ShutdownRequest) ProtoReflect() protoreflect.Message {
	mi := &file_torrent_parser_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ShutdownRequest.ProtoReflect.Descriptor instead.
func (*ShutdownRequest) Descriptor() ([]byte, []int) {
	return file_torrent_parser_proto_rawDescGZIP(), []int{2}
}

type ShutdownResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ShutdownResponse) Reset() {
	*x = ShutdownResponse{}
	mi := &file_torrent_parser_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ShutdownResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ShutdownResponse) ProtoMessage() {}

func (x *ShutdownResponse) ProtoReflect() protoreflect.Message {
	mi := &file_torrent_parser_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ShutdownResponse.ProtoReflect.Descriptor instead.
func (*ShutdownResponse) Descriptor() ([]byte, []int) {
	return file_torrent_parser_proto_rawDescGZIP(), []int{3}
}

var File_torrent_parser_proto protoreflect.FileDescriptor

const file_torrent_parser_proto_rawDesc = "" +
	"\n" +
	"\x14torrent_parser.proto\x12\rtorrentparser\"H\n" +
	"\x13TorrentTitleRequest\x12\x1b\n" +
	"\tinfo_hash\x18\x01 \x01(\tR\binfoHash\x12\x14\n" +
	"\x05title\x18\x02 \x01(\tR\x05title\"\xd9\b\n" +
	"\x14TorrentTitleResponse\x12\x1b\n" +
	"\tinfo_hash\x18\x01 \x01(\tR\binfoHash\x12%\n" +
	"\x0eoriginal_title\x18\x02 \x01(\tR\roriginalTitle\x12\x14\n" +
	"\x05audio\x18\x03 \x03(\tR\x05audio\x12\x1b\n" +
	"\tbit_depth\x18\x04 \x01(\tR\bbitDepth\x12\x1a\n" +
	"\bchannels\x18\x05 \x03(\tR\bchannels\x12\x14\n" +
	"\x05codec\x18\x06 \x01(\tR\x05codec\x12\x1e\n" +
	"\n" +
	"commentary\x18\a \x01(\bR\n" +
	"commentary\x12\x1a\n" +
	"\bcomplete\x18\b \x01(\bR\bcomplete\x12\x1c\n" +
	"\tcontainer\x18\t \x01(\tR\tcontainer\x12\x18\n" +
	"\aconvert\x18\n" +
	" \x01(\bR\aconvert\x12\x12\n" +
	"\x04date\x18\v \x01(\tR\x04date\x12 \n" +
	"\vdocumentary\x18\f \x01(\bR\vdocumentary\x12\x16\n" +
	"\x06dubbed\x18\r \x01(\bR\x06dubbed\x12\x18\n" +
	"\aedition\x18\x0e \x01(\tR\aedition\x12!\n" +
	"\fepisode_code\x18\x0f \x01(\tR\vepisodeCode\x12\x1a\n" +
	"\bepisodes\x18\x10 \x03(\x05R\bepisodes\x12\x1a\n" +
	"\bextended\x18\x11 \x01(\bR\bextended\x12\x1c\n" +
	"\textension\x18\x12 \x01(\tR\textension\x12\x14\n" +
	"\x05group\x18\x13 \x01(\tR\x05group\x12\x10\n" +
	"\x03hdr\x18\x14 \x03(\tR\x03hdr\x12\x1c\n" +
	"\thardcoded\x18\x15 \x01(\bR\thardcoded\x12\x1c\n" +
	"\tlanguages\x18\x16 \x03(\tR\tlanguages\x12\x18\n" +
	"\anetwork\x18\x17 \x01(\tR\anetwork\x12\x16\n" +
	"\x06proper\x18\x18 \x01(\bR\x06proper\x12\x18\n" +
	"\aquality\x18\x19 \x01(\tR\aquality\x12\x16\n" +
	"\x06region\x18\x1a \x01(\tR\x06region\x12\x1e\n" +
	"\n" +
	"remastered\x18\x1b \x01(\bR\n" +
	"remastered\x12\x16\n" +
	"\x06repack\x18\x1c \x01(\bR\x06repack\x12\x1e\n" +
	"\n" +
	"resolution\x18\x1d \x01(\tR\n" +
	"resolution\x12\x16\n" +
	"\x06retail\x18\x1e \x01(\bR\x06retail\x12\x18\n" +
	"\aseasons\x18\x1f \x03(\x05R\aseasons\x12\x12\n" +
	"\x04site\x18  \x01(\tR\x04site\x12\x12\n" +
	"\x04size\x18! \x01(\tR\x04size\x12\x16\n" +
	"\x06subbed\x18\" \x01(\bR\x06subbed\x12\x17\n" +
	"\athree_d\x18# \x01(\tR\x06threeD\x12\x14\n" +
	"\x05title\x18$ \x01(\tR\x05title\x12\x1e\n" +
	"\n" +
	"uncensored\x18% \x01(\bR\n" +
	"uncensored\x12\x18\n" +
	"\aunrated\x18& \x01(\bR\aunrated\x12\x1a\n" +
	"\bupscaled\x18' \x01(\bR\bupscaled\x12\x18\n" +
	"\avolumes\x18( \x03(\x05R\avolumes\x12\x12\n" +
	"\x04year\x18) \x01(\tR\x04year\"\x11\n" +
	"\x0fShutdownRequest\"\x12\n" +
	"\x10ShutdownResponse2\xb8\x01\n" +
	"\rTorrentParser\x12Z\n" +
	"\vParseTitles\x12\".torrentparser.TorrentTitleRequest\x1a#.torrentparser.TorrentTitleResponse(\x010\x01\x12K\n" +
	"\bShutdown\x12\x1e.torrentparser.ShutdownRequest\x1a\x1f.torrentparser.ShutdownResponseBZZ;github.com/ipromknight/zilean/src/GoPttServer/torrentparser\xaa\x02\x1aZilean.Proto.TorrentParserb\x06proto3"

var (
	file_torrent_parser_proto_rawDescOnce sync.Once
	file_torrent_parser_proto_rawDescData []byte
)

func file_torrent_parser_proto_rawDescGZIP() []byte {
	file_torrent_parser_proto_rawDescOnce.Do(func() {
		file_torrent_parser_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_torrent_parser_proto_rawDesc), len(file_torrent_parser_proto_rawDesc)))
	})
	return file_torrent_parser_proto_rawDescData
}

var file_torrent_parser_proto_msgTypes = make([]protoimpl.MessageInfo, 4)
var file_torrent_parser_proto_goTypes = []any{
	(*TorrentTitleRequest)(nil),  // 0: torrentparser.TorrentTitleRequest
	(*TorrentTitleResponse)(nil), // 1: torrentparser.TorrentTitleResponse
	(*ShutdownRequest)(nil),      // 2: torrentparser.ShutdownRequest
	(*ShutdownResponse)(nil),     // 3: torrentparser.ShutdownResponse
}
var file_torrent_parser_proto_depIdxs = []int32{
	0, // 0: torrentparser.TorrentParser.ParseTitles:input_type -> torrentparser.TorrentTitleRequest
	2, // 1: torrentparser.TorrentParser.Shutdown:input_type -> torrentparser.ShutdownRequest
	1, // 2: torrentparser.TorrentParser.ParseTitles:output_type -> torrentparser.TorrentTitleResponse
	3, // 3: torrentparser.TorrentParser.Shutdown:output_type -> torrentparser.ShutdownResponse
	2, // [2:4] is the sub-list for method output_type
	0, // [0:2] is the sub-list for method input_type
	0, // [0:0] is the sub-list for extension type_name
	0, // [0:0] is the sub-list for extension extendee
	0, // [0:0] is the sub-list for field type_name
}

func init() { file_torrent_parser_proto_init() }
func file_torrent_parser_proto_init() {
	if File_torrent_parser_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_torrent_parser_proto_rawDesc), len(file_torrent_parser_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   4,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_torrent_parser_proto_goTypes,
		DependencyIndexes: file_torrent_parser_proto_depIdxs,
		MessageInfos:      file_torrent_parser_proto_msgTypes,
	}.Build()
	File_torrent_parser_proto = out.File
	file_torrent_parser_proto_goTypes = nil
	file_torrent_parser_proto_depIdxs = nil
}
